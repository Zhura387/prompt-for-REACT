import React from 'react';


function State() {
  return (
    <div>

      <h1>Использование хука состояния</h1>

      <p>На странице введения в хуки мы познакомились с ними на этом примере:</p>

      <pre>{`
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
`}</pre>


      <p>Давайте начнём изучать хуки, сравнив этот код с эквивалентным кодом на основе класса.</p>

      <h2>Хуки и функциональные компоненты</h2>
      <p>Напоминаем, что функциональные компоненты в React выглядят так:</p>
      <pre>{`
const Example = (props) => {
    // Тут мог бы быть ваш хук!
    return <div />;
  }
`}</pre>

      <p>или так:</p>

      <pre>{`
function Example(props) {
    // Тут мог бы быть ваш хук!
    return <div />;
  }
`}</pre>

      <p>Возможно, вы слышали, что такие компоненты называются «компонентами без состояния». Сейчас мы покажем, как использовать внутри них состояние React, поэтому будем называть их «функциональными компонентами».</p>

      <p>Хуки НЕ работают внутри классов, а используются вместо них.</p>

      <h2>Что такое хук?</h2>
      <p>Наш новый пример начинается с того, что импортирует хук useState из React:</p>
      <pre>{`
import React, { useState } from 'react';

function Example() {
  // ...
}
`}</pre>


      <p>Что такое хук? Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. Мы узнаем про другие хуки чуть позже.</p>

      <p>Когда применить хук? Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента. Мы покажем это прямо сейчас!</p>

      <p>Примечание:

        Есть специальные правила о том, где можно, а где нельзя использовать хуки внутри компонента. Их мы изучим в главе Правила хуков.</p>

      <h2>Резюме</h2>

      <p>Давайте построчно пробежимся по тому, что мы выучили и проверим наши знания:</p>
      <pre>{`
   import React, { useState } from 'react';
 
   function Example() {
     const [count, setCount] = useState(0);
 
     return (
       <div>
         <p>Вы кликнули {count} раз(а)</p>
         <button onClick={() => setCount(count + 1)}>
         Нажми на меня
        </button>
      </div>
    );
  }
`}</pre>

      <p>Строка 1: Импортируем хук useState из React. Он позволяет функциональному компоненту хранить внутреннее состояние.</p>
      <p>Строка 4: Объявляем внутри компонента Example новую переменную состояния, вызвав хук useState. Этот вызов возвращает пару значений, которым мы даём имена. Поскольку наша переменная состояния хранит количество сделанных по кнопке кликов, мы называем её count. Чтобы проинициализировать её, мы передаём значение 0 в качестве единственного аргумента функции useState. Второе возвращённое нам значение позволяет обновлять count, поэтому мы называем её setCount.</p>
      <p>Строка 9: Когда пользователь кликает по кнопке, мы вызываем setCount с приращённым значением. После этого React сделает повторный рендер, в котором использует уже новое значение count.</p>
      <p>Поначалу это всё может показаться слишком сложным. Не торопитесь! Если вы запутались в объяснении, ещё раз прочитайте приведённый код с начала до конца. Обещаем, если вы на минутку «забудете», как состояние работает в классах, и посмотрите на код свежим взглядом, всё станет ясно.</p>

      <h2>Совет: Что делают квадратные скобки?</h2>
      <p>Вы могли обратить внимание на квадратные скобки в месте, где объявляется переменная состояния:</p>
      <pre>{`
  const [count, setCount] = useState(0);
`}</pre>

      <p>Два имени в квадратных скобках не содержатся в API React. Названия переменным состояния выбираете вы:</p>

      <pre>{`
  const [fruit, setFruit] = useState('банан');
`}</pre>

      <p>Такой синтаксис в JavaScript называется «деструктуризацией массивов (array destructuring)». Он означает, что мы создаём две новые переменные, fruit и setFruit. Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе, что равносильно такому коду:</p>
      <pre>{`
  var fruitStateVariable = useState('банан'); // Возвращает пару значений
  var fruit = fruitStateVariable[0]; // Извлекаем первое значение
  var setFruit = fruitStateVariable[1]; // Извлекаем второе значение
`}</pre>

      <p>Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение. Доступ к элементам через [0] и [1] менее ясен, потому что индексы лишены осмысленных имён.</p>

      <p>Примечание

        Вам может быть любопытно, а как же React знает, какому компоненту соответствует какой вызов useState, если мы не передаём React ни this ни чего-либо подобного. Ответ на этот и многие другие вопросы мы дадим в FAQ.</p>



    </div>
  )
}
export default State;